import * as fs from "fs";
import { JSX } from "solid-js";

type PropertyType = "string" | "number" | "boolean" | string[];

type Properties = Record<string, PropertyType>;

type Events = Record<string, string>;

type Input = { className: any; props: any; events: any };

type Output = { className: string; props: Properties; events: Events };

declare function __collectProperties<T extends Record<string, Input>>(): Record<
  keyof T,
  Output
>;

type DummyClass = Node;

const {
  events: { events: EVENTS },
  aria: { props: ARIA_PROPS },
  html: { props: HTML_PROPS },
  svg: { props: SVG_PROPS },
} = __collectProperties<{
  events: {
    className: DummyClass;
    props: {};
    events: HTMLElement["addEventListener"];
  };
  aria: {
    className: DummyClass;
    props: ARIAMixin;
    events: undefined;
  };
  html: {
    className: DummyClass;
    props: Omit<HTMLElement, keyof Node | keyof ARIAMixin>;
    events: undefined;
  };
  svg: {
    className: DummyClass;
    props: Omit<JSX.CoreSVGAttributes<SVGAElement>, keyof JSX.AriaAttributes>;
    events: undefined;
  };
}>();

const HTML_ELEMENT_MAP = __collectProperties<{
  [K in keyof HTMLElementTagNameMap]: {
    className: HTMLElementTagNameMap[K];
    // TODO: extends types in `solid-js`
    props: Omit<HTMLElementTagNameMap[K], keyof HTMLElement>;
    events: HTMLElementTagNameMap[K]["addEventListener"];
  };
}>();

const SVG_ELEMENT_MAP = __collectProperties<{
  [K in keyof JSX.SVGElementTags]: {
    className: SVGElementTagNameMap[K];
    props: Omit<
      JSX.SVGElementTags[K],
      keyof JSX.CoreSVGAttributes<SVGAElement> | keyof ARIAMixin
    >;
    events: SVGElementTagNameMap[K]["addEventListener"];
  };
}>();

const EXCLUDE_EVENTS: Record<string, any> = {};

const EXCLUDE_PROPS: Record<string, any> = {
  $ServerOnly: true,
  children: true,
  innerHTML: true,
  innerText: true,
  textContent: true,
};

class PresetCollector {
  private result = "";

  collect(): string {
    this.start();

    this.startInsertPredefiend("EVENT");
    this.insertEvents(EVENTS);
    this.finishInsert();

    this.startInsertPredefiend("ARIA");
    this.insertProps(ARIA_PROPS);
    this.finishInsert();

    this.startInsertPredefiend("HTML");
    this.insertExtends("EVENT", "ARIA");
    this.insertProps(HTML_PROPS);
    this.finishInsert();

    this.startInsertPredefiend("SVG");
    this.insertExtends("EVENT", "ARIA");
    this.insertProps(SVG_PROPS, true);
    this.finishInsert();

    for (const [tag, { className, props, events }] of Object.entries(
      HTML_ELEMENT_MAP
    )) {
      this.startInsertElement(tag, { className });
      this.insertExtends("HTML");
      this.insertEvents(events, EVENTS);
      this.insertProps(props);
      this.finishInsert();
    }

    for (const [tag, { className, props, events }] of Object.entries(
      SVG_ELEMENT_MAP
    )) {
      this.startInsertElement(tag, {
        className,
        namespace: "http://www.w3.org/2000/svg",
      });
      this.insertExtends("SVG");
      this.insertEvents(events, EVENTS);
      this.insertProps(props, true);
      this.finishInsert();
    }

    return this.finish();
  }

  private start() {
    this.result = "// This file is @generated by web-types.\n";
  }

  private finish(): string {
    return this.result;
  }

  private insertExtends(...names: string[]) {
    for (const name of names) {
      this.insertRaw(`+${name}`);
    }
  }

  private insertEvents(events: Events, exclude = EXCLUDE_EVENTS) {
    const sorted = Object.entries(recordExlucde(events, exclude)).sort();
    for (const [key, val] of sorted) {
      if (key.startsWith("webkit")) {
        continue;
      }
      this.insertRaw(`@${key}: ${val}`);
    }
  }

  private insertProps(
    props: Properties,
    attribute = false,
    exclude = EXCLUDE_PROPS
  ) {
    const sorted = Object.entries(recordExlucde(props, exclude)).sort();
    for (const [key, val] of sorted) {
      if (key.startsWith("webkit")) {
        continue;
      }
      // names in different cases, e.g. 'tabindex' and 'tabIndex'
      // 'tabIndex' will be ignore
      const lower = key.toLowerCase();
      if (key !== lower && lower in props) {
        continue;
      }
      let name = key;
      let type: string;
      if (typeof val == "string") {
        type = val;
      } else {
        type = this.literalProp(val);
      }
      let prefix = "";
      if (attribute) {
        prefix = "*";
      }
      this.insertRaw(`${prefix}${name}: ${type}`);
    }
  }

  private literalProp(literals: string[]): string {
    literals = literals.sort();
    if (arrayEqual(literals, ["false", "true"])) {
      return "boolean";
    }
    const values = literals.map((v) => `"${v}"`).join(" ");
    return `(${values})`;
  }

  private startInsertPredefiend(name: string) {
    this.startInsert(`+${name}`);
  }

  private startInsertElement(
    tag: string,
    { className, namespace }: { className: string; namespace?: string }
  ) {
    const argStrs = [`class=${className}`];
    if (namespace !== undefined) {
      argStrs.push(`ns="${namespace}"`);
    }
    this.startInsert(`${tag}(${argStrs.join(" ")})`);
  }

  private startInsert(head: string) {
    this.result += `${head} {`;
  }

  private insertRaw(content: string) {
    this.result += `\n    ${content},`;
  }

  private finishInsert() {
    this.result += `\n}\n`;
  }
}

function recordExlucde<T>(
  a: Record<string, T>,
  exlucde: Record<string, any>
): Record<string, T> {
  const result: Record<string, T> = {};
  for (const k in a) {
    if (!(k in exlucde)) {
      result[k] = a[k];
    }
  }
  return result;
}

function arrayEqual<T>(a: T[], b: T[]): boolean {
  if (a === b) {
    return true;
  } else if (a.length !== b.length) {
    return false;
  } else {
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
}

const path = process.argv[2];
const content = new PresetCollector().collect();
if (path === undefined) {
  console.log(content);
} else {
  fs.writeFileSync(path, content);
}
