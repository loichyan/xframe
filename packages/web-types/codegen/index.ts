import * as fs from "fs";
import { JSX } from "solid-js";

type PropertyType = "string" | "number" | "boolean" | string[];

type Properties = Record<string, PropertyType>;

type Events = Record<string, string>;

type Input = { className: any; props: any; events: any };

type Output = { className: string; props: Properties; events: Events };

declare function __collectProperties<T extends Record<string, Input>>(): Record<
  keyof T,
  Output
>;

const {
  events: { events: EVENTS },
  aria: { props: ARIA_PROPS },
  html: { props: HTML_PROPS },
  solidHtml,
  svg,
} = __collectProperties<{
  events: {
    className: undefined;
    props: {};
    events: HTMLElement["addEventListener"];
  };
  aria: {
    className: undefined;
    props: ARIAMixin;
    events: undefined;
  };
  html: {
    className: undefined;
    props: Omit<HTMLElement, keyof Node | keyof ARIAMixin>;
    events: undefined;
  };
  solidHtml: {
    className: undefined;
    props: JSX.HTMLAttributes<HTMLElement>;
    events: undefined;
  };
  svg: {
    className: undefined;
    props: Omit<JSX.CoreSVGAttributes<SVGAElement>, keyof JSX.AriaAttributes>;
    events: undefined;
  };
}>();

const HTML_ELEMENT_MAP = __collectProperties<{
  [K in keyof HTMLElementTagNameMap]: {
    className: HTMLElementTagNameMap[K];
    props: Omit<HTMLElementTagNameMap[K], keyof HTMLElement>;
    events: HTMLElementTagNameMap[K]["addEventListener"];
  };
}>();

const SOLID_HTML_ELEMENT_MAP = __collectProperties<{
  [K in keyof JSX.HTMLElementTags]: {
    className: undefined;
    props: Omit<JSX.HTMLElementTags[K], keyof JSX.HTMLAttributes<HTMLElement>>;
    events: undefined;
  };
}>();

const SVG_ELEMENT_MAP = __collectProperties<{
  [K in keyof JSX.SVGElementTags]: {
    className: SVGElementTagNameMap[K];
    props: Omit<
      JSX.SVGElementTags[K],
      keyof JSX.CoreSVGAttributes<SVGAElement> | keyof ARIAMixin
    >;
    events: SVGElementTagNameMap[K]["addEventListener"];
  };
}>();

const EXCLUDE_EVENTS: Record<string, any> = {};

const EXCLUDE_PROPS: Record<string, any> = {
  innerHTML: true,
  innerText: true,
  outerHTML: true,
  outerText: true,
  children: true,
  textContent: true,
};

const SOLID_EXCLUDE_PROPS: Record<string, any> = {
  $ServerOnly: true,
};

function solidProps(props: Properties): Properties {
  props = recordExlucde(props, SOLID_EXCLUDE_PROPS);
  const result: Properties = {};
  for (const k in props) {
    // names in different cases, e.g. 'tabindex' and 'tabIndex'
    // 'tabIndex' will be ignore
    const lower = k.toLowerCase();
    if (k !== lower && lower in props) {
      continue;
    }
    result[k] = props[k];
  }
  return result;
}

const SOLID_HTML_PROPS = solidProps(solidHtml.props);
const SVG_PROPS = solidProps(svg.props);

SOLID_HTML_ELEMENT_MAP.ol.props.type = "string";
for (const val of Object.values(SOLID_HTML_ELEMENT_MAP)) {
  val.props = solidProps(val.props);
  if ("formenctype" in val.props) {
    val.props["formenctype"] = "string";
  }
}

class PresetCollector {
  private result = "";

  collect(): string {
    this.start();

    this.startInsertPredefiend("EVENT");
    this.insertEvents(EVENTS);
    this.finishInsert();

    this.startInsertPredefiend("ARIA");
    this.insertProps(this.overrideWithSolid(ARIA_PROPS, SOLID_HTML_PROPS));
    this.finishInsert();

    this.startInsertPredefiend("HTML");
    this.insertExtends("EVENT", "ARIA");
    this.insertProps(HTML_PROPS);
    this.finishInsert();

    this.startInsertPredefiend("SVG");
    this.insertExtends("EVENT", "ARIA");
    this.insertProps(SVG_PROPS, true);
    this.finishInsert();

    for (const [tag, { className, props, events }] of Object.entries(
      HTML_ELEMENT_MAP
    )) {
      this.startInsertElement(tag, { className });
      this.insertExtends("HTML");
      this.insertEvents(events, EVENTS);
      this.insertProps(
        tag in SOLID_HTML_ELEMENT_MAP
          ? this.overrideWithSolid(
              props,
              SOLID_HTML_ELEMENT_MAP[tag as keyof JSX.HTMLElementTags].props
            )
          : props
      );
      this.finishInsert();
    }

    for (const [tag, { className, props, events }] of Object.entries(
      SVG_ELEMENT_MAP
    )) {
      this.startInsertElement(tag, {
        className,
        namespace: "http://www.w3.org/2000/svg",
      });
      this.insertExtends("SVG");
      this.insertEvents(events, EVENTS);
      this.insertProps(props, true);
      this.finishInsert();
    }

    return this.finish();
  }

  private start() {
    this.result = "// This file is @generated by web-types.\n";
  }

  private finish(): string {
    return this.result;
  }

  private insertExtends(...names: string[]) {
    for (const name of names) {
      this.insertRaw(`+${name}`);
    }
  }

  private insertEvents(events: Events, exclude = EXCLUDE_EVENTS) {
    const sorted = Object.entries(recordExlucde(events, exclude)).sort();
    for (const [key, val] of sorted) {
      if (key.startsWith("webkit")) {
        continue;
      }
      this.insertRaw(`@${key}: ${val}`);
    }
  }

  private overrideWithSolid(html: Properties, solid: Properties): Properties {
    const result: Properties = {};
    const override: Properties = {};
    for (const k in solid) {
      override[k.replaceAll("-", "").toLowerCase()] = solid[k];
    }
    for (const k in html) {
      const solidType = override[k.toLowerCase()];
      if (solidType !== undefined) {
        result[k] = solidType;
      } else {
        result[k] = html[k];
      }
    }
    return result;
  }

  private insertProps(
    props: Properties,
    attribute = false,
    exclude = EXCLUDE_PROPS
  ) {
    const sorted = Object.entries(recordExlucde(props, exclude)).sort();
    for (const [key, val] of sorted) {
      if (key.startsWith("webkit")) {
        continue;
      }
      let name = key;
      let type: string;
      if (typeof val == "string") {
        type = val;
      } else {
        type = this.literalProp(val);
      }
      let prefix = "";
      if (attribute) {
        prefix = "*";
      }
      this.insertRaw(`${prefix}${name}: ${type}`);
    }
  }

  private literalProp(literals: string[]): string {
    const values = literals
      .sort()
      .map((v) => `"${v}"`)
      .join(" ");
    return `(${values})`;
  }

  private startInsertPredefiend(name: string) {
    this.startInsert(`+${name}`);
  }

  private startInsertElement(
    tag: string,
    { className, namespace }: { className: string; namespace?: string }
  ) {
    const argStrs = [`class=${className}`];
    if (namespace !== undefined) {
      argStrs.push(`ns="${namespace}"`);
    }
    this.startInsert(`${tag}(${argStrs.join(" ")})`);
  }

  private startInsert(head: string) {
    this.result += `${head} {`;
  }

  private insertRaw(content: string) {
    this.result += `\n    ${content},`;
  }

  private finishInsert() {
    this.result += `\n}\n`;
  }
}

function recordExlucde<T>(
  a: Record<string, T>,
  exlucde: Record<string, any>
): Record<string, T> {
  const result: Record<string, T> = {};
  for (const k in a) {
    if (!(k in exlucde)) {
      result[k] = a[k];
    }
  }
  return result;
}

const path = process.argv[2];
const content = new PresetCollector().collect();
if (path === undefined) {
  console.log(content);
} else {
  fs.writeFileSync(path, content);
}
