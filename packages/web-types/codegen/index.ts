import * as fs from "fs";
import { JSX } from "solid-js";

type PropertyType = "string" | "number" | "boolean" | string[];

type Properties = { [k: string]: PropertyType };

type Events = { [k: string]: string };

declare function __collectProperties<
  T extends { [k: string]: { className: any; props: any; events: any } }
>(): {
  [K in keyof T]: {
    className: string;
    props: Properties;
    events: Events;
  };
};

type DummyClass = Node;

const {
  events: { events: EVENTS },
  aria: { props: ARIA_PROPS },
  html: { props: HTML_PROPS },
  svg: { props: SVG_PROPS },
} = __collectProperties<{
  events: {
    className: DummyClass;
    props: {};
    events: HTMLElement["addEventListener"];
  };
  aria: {
    className: DummyClass;
    props: ARIAMixin;
    events: undefined;
  };
  html: {
    className: DummyClass;
    props: Omit<HTMLElement, keyof Node | keyof ARIAMixin>;
    events: undefined;
  };
  svg: {
    className: DummyClass;
    props: Omit<JSX.CoreSVGAttributes<SVGAElement>, keyof JSX.AriaAttributes>;
    events: undefined;
  };
}>();

const HTML_ELEMENT_MAP = __collectProperties<{
  [K in keyof HTMLElementTagNameMap]: {
    className: HTMLElementTagNameMap[K];
    // TODO: extends types in `solid-js`
    props: Omit<HTMLElementTagNameMap[K], keyof HTMLElement>;
    events: HTMLElementTagNameMap[K]["addEventListener"];
  };
}>();

const SVG_ELEMENT_MAP = __collectProperties<{
  [K in keyof JSX.SVGElementTags]: {
    className: SVGElementTagNameMap[K];
    props: Omit<
      JSX.SVGElementTags[K],
      keyof JSX.CoreSVGAttributes<SVGAElement> | keyof ARIAMixin
    >;
    events: SVGElementTagNameMap[K]["addEventListener"];
  };
}>();

const EXCLUDE_PROPS: { [k: string]: true | undefined } = {
  $ServerOnly: true,
  children: true,
  innerHTML: true,
  innerText: true,
  textContent: true,
};

class PresetCollector {
  private result = "";

  collect(): string {
    this.start();

    this.startInsert("+EVENT");
    this.insertEvents(EVENTS);
    this.finishInsert();

    this.startInsert("+ARIA");
    this.insertProps(ARIA_PROPS);
    this.finishInsert();

    this.startInsert("+HTML");
    this.insertRaw("+EVENT");
    this.insertRaw("+ARIA");
    this.insertProps(HTML_PROPS);
    this.finishInsert();

    this.startInsert("+SVG");
    this.insertRaw("+EVENT");
    this.insertRaw("+ARIA");
    this.insertProps(SVG_PROPS, true);
    this.finishInsert();

    // Collect properties of each Element.
    for (const [tag, { className, props, events }] of Object.entries(
      HTML_ELEMENT_MAP
    )) {
      this.startInsert(`${tag} => ${className}`);
      this.insertRaw(`+HTML`);
      this.insertEvents(events, EVENTS);
      this.insertProps(props);
      this.finishInsert();
    }

    // Collect properties of each Element.
    for (const [tag, { className, props, events }] of Object.entries(
      SVG_ELEMENT_MAP
    )) {
      this.startInsert(`${tag} => ${className}`);
      this.insertRaw(`+SVG`);
      this.insertEvents(events, EVENTS);
      this.insertProps(props, true);
      this.finishInsert();
    }

    return this.finish();
  }

  private start() {
    this.result = "// This file is @generated by web-types.\n";
  }

  private finish(): string {
    return this.result;
  }

  private insertEvents(events: Events, exclude: Events = {}) {
    const sorted = Object.entries(events)
      .filter(([key]) => exclude[key] === undefined)
      .sort();
    for (const [key, val] of sorted) {
      if (key.startsWith("webkit")) {
        continue;
      }
      this.insertRaw(`@${key}: ${val}`);
    }
  }

  private insertProps(props: Properties, attribute: boolean = false) {
    const sorted = Object.entries(props).sort();
    for (const [key, val] of sorted) {
      if (key.startsWith("webkit") || key in EXCLUDE_PROPS) {
        continue;
      }
      const lower = key.toLowerCase();
      if (key !== lower && lower in props) {
        continue;
      }
      let name = key;
      let type: string;
      if (typeof val == "string") {
        type = val;
      } else {
        type = this.literalProp(val);
      }
      let prefix = "";
      if (attribute) {
        prefix = "*";
      }
      this.insertRaw(`${prefix}${name}: ${type}`);
    }
  }

  private literalProp(literals: string[]): string {
    literals = literals.sort();
    if (arrayEqual(literals, ["false", "true"])) {
      return "boolean";
    }
    const values = literals.map((v) => `"${v}"`).join(" ");
    return `(${values})`;
  }

  private startInsert(head: string) {
    this.result += `${head} {`;
  }

  private insertRaw(content: string) {
    this.result += `\n    ${content},`;
  }

  private finishInsert() {
    this.result += `\n}\n`;
  }
}

function arrayEqual<T>(a: T[], b: T[]): boolean {
  if (a === b) {
    return true;
  } else if (a.length !== b.length) {
    return false;
  } else {
    for (let i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
}

const path = process.argv[2];
const content = new PresetCollector().collect();
if (path === undefined) {
  console.log(content);
} else {
  fs.writeFileSync(path, content);
}
